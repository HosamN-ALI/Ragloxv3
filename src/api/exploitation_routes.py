# ═══════════════════════════════════════════════════════════════
# RAGLOX v3.0 - Exploitation & C2 API Routes
# Real-time session management and exploitation monitoring
# ═══════════════════════════════════════════════════════════════

import logging
import time
import asyncio
from typing import Dict, List, Optional, Any
from fastapi import APIRouter, HTTPException, status, Depends, Request
from pydantic import BaseModel, Field, ValidationError
from functools import lru_cache

from ..core.exceptions import (
    RAGLOXException,
    ServiceUnavailableError,
    ExploitationException,
    ConnectionTimeoutError,
    sanitize_error_message,
)

logger = logging.getLogger("raglox.api.exploitation")


def handle_api_exception(e: Exception, operation: str) -> HTTPException:
    """
    Convert exceptions to appropriate HTTP responses.
    
    Args:
        e: The exception to handle
        operation: Description of the operation that failed
        
    Returns:
        HTTPException with appropriate status code
    """
    # Sanitize error message to remove sensitive data
    safe_message = sanitize_error_message(str(e))
    
    if isinstance(e, HTTPException):
        raise e
    elif isinstance(e, ValidationError):
        logger.warning(f"Validation error in {operation}: {safe_message}")
        return HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Validation error: {safe_message}"
        )
    elif isinstance(e, asyncio.TimeoutError):
        logger.warning(f"Timeout in {operation}: {safe_message}")
        return HTTPException(
            status_code=status.HTTP_504_GATEWAY_TIMEOUT,
            detail=f"Operation timed out: {operation}"
        )
    elif isinstance(e, (ConnectionError, OSError)):
        logger.error(f"Connection error in {operation}: {safe_message}")
        return HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=f"Service connection error: {operation}"
        )
    elif isinstance(e, RAGLOXException):
        logger.error(f"RAGLOX error in {operation}: {safe_message}")
        return HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    else:
        logger.exception(f"Unexpected error in {operation}")
        return HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Internal error during {operation}"
        )

# PERF-08: Response caching configuration
RESPONSE_CACHE_TTL = 60  # 60 seconds for status endpoints

# Simple TTL cache implementation for async functions
class TTLCache:
    """Simple TTL cache for async function results."""
    def __init__(self, ttl: int = 60):
        self.ttl = ttl
        self._cache: Dict[str, Any] = {}
        self._timestamps: Dict[str, float] = {}
    
    def get(self, key: str) -> Optional[Any]:
        if key in self._cache:
            if time.time() - self._timestamps.get(key, 0) < self.ttl:
                return self._cache[key]
            else:
                # Expired
                del self._cache[key]
                del self._timestamps[key]
        return None
    
    def set(self, key: str, value: Any):
        self._cache[key] = value
        self._timestamps[key] = time.time()
    
    def clear(self):
        self._cache.clear()
        self._timestamps.clear()

# Global caches for status endpoints
_metasploit_status_cache = TTLCache(ttl=RESPONSE_CACHE_TTL)
_exploitation_status_cache = TTLCache(ttl=RESPONSE_CACHE_TTL)
_exploit_stats_cache = TTLCache(ttl=RESPONSE_CACHE_TTL)

router = APIRouter(prefix="/exploitation", tags=["Exploitation"])


# ═══════════════════════════════════════════════════════════════
# Request/Response Models
# ═══════════════════════════════════════════════════════════════

class C2SessionInfo(BaseModel):
    """C2 Session information."""
    session_id: str
    target_host: str
    target_port: int
    session_type: str  # "ssh", "meterpreter", "shell", etc.
    status: str  # "active", "inactive", "error"
    created_at: str
    last_heartbeat: Optional[str] = None
    encryption_enabled: bool
    privilege_level: Optional[str] = None
    commands_executed: int = 0
    data_exfiltrated_bytes: int = 0


class C2CommandRequest(BaseModel):
    """Execute command on C2 session."""
    session_id: str = Field(..., description="Target C2 session ID")
    command: str = Field(..., description="Command to execute")
    timeout: int = Field(default=30, description="Command timeout in seconds")


class C2CommandResponse(BaseModel):
    """C2 command execution result."""
    success: bool
    session_id: str
    command: str
    output: Optional[str] = None
    error: Optional[str] = None
    execution_time: float
    timestamp: str


class ExploitStatusRequest(BaseModel):
    """Request exploit status."""
    exploit_id: Optional[str] = None
    target_id: Optional[str] = None


class ExploitStatusResponse(BaseModel):
    """Exploit execution status."""
    exploit_id: str
    target_id: str
    status: str  # "pending", "running", "success", "failed"
    exploit_type: str
    started_at: str
    completed_at: Optional[str] = None
    session_id: Optional[str] = None
    error: Optional[str] = None


class SessionProxyRequest(BaseModel):
    """Setup SOCKS proxy via session."""
    session_id: str
    proxy_port: int = Field(default=1080, description="Local SOCKS proxy port")
    proxy_type: str = Field(default="socks5", description="Proxy type: socks4/socks5")


class ExploitInfo(BaseModel):
    """Exploit metadata."""
    exploit_id: str
    name: str
    description: str
    cve_ids: List[str]
    platforms: List[str]
    targets: List[str]
    reliability: str
    exploit_type: str
    success_rate: float
    total_attempts: int = 0
    successful_attempts: int = 0


class PayloadRequest(BaseModel):
    """Generate custom payload."""
    payload_type: str = Field(..., description="meterpreter, reverse_shell, bind_shell, etc.")
    target_os: str = Field(..., description="windows, linux, macos")
    architecture: str = Field(default="x64", description="x86, x64, arm")
    lhost: str = Field(..., description="Listener host")
    lport: int = Field(..., description="Listener port")
    encoder: Optional[str] = Field(None, description="shikata_ga_nai, xor, etc.")
    iterations: int = Field(default=1, description="Encoding iterations")


class PayloadResponse(BaseModel):
    """Generated payload."""
    success: bool
    payload_type: str
    payload_data: str
    payload_size: int
    encoded: bool
    encoder: Optional[str] = None


class CredentialHarvestRequest(BaseModel):
    """Harvest credentials request."""
    session_id: str
    harvest_type: str = Field(..., description="mimikatz, lsass, sam, browsers")
    target_path: Optional[str] = None


class PortForwardRequest(BaseModel):
    """Port forwarding request."""
    session_id: str
    local_port: int
    remote_host: str
    remote_port: int


# ═══════════════════════════════════════════════════════════════
# C2 Session Management Endpoints
# ═══════════════════════════════════════════════════════════════

@router.get("/c2/sessions", response_model=List[C2SessionInfo])
async def list_c2_sessions(
    request: Request,
    mission_id: Optional[str] = None,
    status: Optional[str] = None
) -> List[C2SessionInfo]:
    """
    List all active C2 sessions.
    
    Args:
        mission_id: Filter by mission ID (optional)
        status: Filter by status: active/inactive/error (optional)
    
    Returns:
        List of C2 session information
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized. Enable USE_REAL_EXPLOITS=true"
            )
        
        # Get all sessions
        sessions = await c2_manager.list_sessions()
        
        # Apply filters
        if mission_id:
            sessions = [s for s in sessions if s.get('mission_id') == mission_id]
        if status:
            sessions = [s for s in sessions if s.get('status') == status]
        
        return [C2SessionInfo(**s) for s in sessions]
        
    except (ConnectionError, OSError, asyncio.TimeoutError) as e:
        # SEC-01: Specific handling for connection errors
        logger.error(f"Connection error listing C2 sessions: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Service temporarily unavailable"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to list C2 sessions: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    except ValueError as e:
        # SEC-01: Handle validation errors
        logger.warning(f"Validation error listing C2 sessions: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid request parameters"
        )


@router.get("/c2/sessions/{session_id}", response_model=C2SessionInfo)
async def get_c2_session(
    request: Request,
    session_id: str
) -> C2SessionInfo:
    """
    Get detailed information about a specific C2 session.
    
    Args:
        session_id: C2 session ID
    
    Returns:
        C2 session information
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        session = await c2_manager.get_session(session_id)
        
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"C2 session {session_id} not found"
            )
        
        return C2SessionInfo(**session)
        
    except HTTPException:
        raise
    except (ConnectionError, OSError, asyncio.TimeoutError) as e:
        # SEC-01: Specific handling for connection errors
        logger.error(f"Connection error getting C2 session: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Service temporarily unavailable"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to get C2 session: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    except (KeyError, ValueError) as e:
        # SEC-01: Handle lookup/validation errors
        logger.warning(f"Error getting C2 session: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Session not found or invalid ID"
        )


@router.post("/c2/sessions/{session_id}/execute", response_model=C2CommandResponse)
async def execute_c2_command(
    request: Request,
    session_id: str,
    command_request: C2CommandRequest
) -> C2CommandResponse:
    """
    Execute a command on a C2 session.
    
    Args:
        session_id: Target C2 session ID
        command_request: Command details
    
    Returns:
        Command execution result
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        # Execute command
        result = await c2_manager.execute_command(
            session_id=session_id,
            command=command_request.command,
            timeout=command_request.timeout
        )
        
        return C2CommandResponse(**result)
        
    except asyncio.TimeoutError as e:
        # SEC-01: Handle command timeout
        logger.warning(f"Command execution timed out: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_504_GATEWAY_TIMEOUT,
            detail="Command execution timed out"
        )
    except (ConnectionError, OSError) as e:
        # SEC-01: Handle connection errors
        logger.error(f"Connection error executing command: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Service temporarily unavailable"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to execute command: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    except ValueError as e:
        # SEC-01: Handle validation errors
        logger.warning(f"Invalid command parameters: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid command parameters"
        )


@router.delete("/c2/sessions/{session_id}")
async def terminate_c2_session(
    request: Request,
    session_id: str
) -> Dict[str, str]:
    """
    Terminate a C2 session.
    
    Args:
        session_id: C2 session ID to terminate
    
    Returns:
        Success message
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        await c2_manager.terminate_session(session_id)
        
        return {
            "status": "success",
            "message": f"C2 session {session_id} terminated"
        }
        
    except (ConnectionError, OSError, asyncio.TimeoutError) as e:
        # SEC-01: Handle connection errors
        logger.error(f"Connection error terminating session: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Service temporarily unavailable"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to terminate session: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    except (KeyError, ValueError) as e:
        # SEC-01: Handle lookup/validation errors
        logger.warning(f"Error terminating session: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Session not found or invalid ID"
        )


@router.post("/c2/sessions/{session_id}/proxy", response_model=Dict[str, Any])
async def setup_socks_proxy(
    request: Request,
    session_id: str,
    proxy_request: SessionProxyRequest
) -> Dict[str, Any]:
    """
    Setup SOCKS proxy through a C2 session for network pivoting.
    
    Args:
        session_id: C2 session to use for proxy
        proxy_request: Proxy configuration
    
    Returns:
        Proxy connection details
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        # Setup SOCKS proxy
        proxy_info = await c2_manager.setup_proxy(
            session_id=session_id,
            proxy_port=proxy_request.proxy_port,
            proxy_type=proxy_request.proxy_type
        )
        
        return {
            "status": "success",
            "proxy_type": proxy_request.proxy_type,
            "proxy_host": "127.0.0.1",
            "proxy_port": proxy_request.proxy_port,
            "session_id": session_id,
            "message": f"SOCKS proxy established on port {proxy_request.proxy_port}"
        }
        
    except (ConnectionError, OSError, asyncio.TimeoutError) as e:
        # SEC-01: Handle connection errors
        logger.error(f"Connection error setting up proxy: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Service temporarily unavailable"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to setup proxy: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    except ValueError as e:
        # SEC-01: Handle validation errors (invalid port, etc.)
        logger.warning(f"Invalid proxy parameters: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid proxy configuration"
        )


# ═══════════════════════════════════════════════════════════════
# Exploitation Status & Monitoring
# ═══════════════════════════════════════════════════════════════

@router.get("/status/metasploit", response_model=Dict[str, Any])
async def get_metasploit_status(request: Request) -> Dict[str, Any]:
    """
    Get Metasploit RPC connection status.
    
    PERF-08: Response cached for 60 seconds.
    
    Returns:
        Metasploit connection and version information
    """
    # PERF-08: Check cache first
    cached = _metasploit_status_cache.get("status")
    if cached:
        return cached
    
    try:
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        use_real_exploits = getattr(request.app.state, 'use_real_exploits', False)
        
        if not use_real_exploits:
            result = {
                "status": "disabled",
                "message": "Real exploitation disabled. Set USE_REAL_EXPLOITS=true",
                "mode": "simulation"
            }
            _metasploit_status_cache.set("status", result)
            return result
        
        if not metasploit_adapter:
            result = {
                "status": "unavailable",
                "message": "Metasploit RPC adapter not initialized",
                "mode": "simulation"
            }
            _metasploit_status_cache.set("status", result)
            return result
        
        # Get Metasploit version and stats
        version = await metasploit_adapter.get_version()
        exploits = await metasploit_adapter.list_exploits()
        
        result = {
            "status": "connected",
            "mode": "real_exploitation",
            "version": version,
            "total_exploits": len(exploits) if exploits else 0,
            "connection": {
                "host": metasploit_adapter.host,
                "port": metasploit_adapter.port,
                "ssl": metasploit_adapter.ssl
            }
        }
        _metasploit_status_cache.set("status", result)
        return result
        
    except (ConnectionError, OSError, asyncio.TimeoutError) as e:
        # SEC-01: Handle connection errors gracefully
        logger.warning(f"Metasploit connection issue: {sanitize_error_message(str(e))}")
        return {
            "status": "connection_error",
            "message": "Unable to connect to Metasploit",
            "mode": "simulation"
        }
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to get Metasploit status: {e.message}")
        return {
            "status": "error",
            "message": e.message,
            "mode": "simulation"
        }
    except (KeyError, ValueError, AttributeError) as e:
        # SEC-01: Handle configuration/attribute errors
        logger.warning(f"Metasploit configuration issue: {sanitize_error_message(str(e))}")
        return {
            "status": "configuration_error",
            "message": "Metasploit not properly configured",
            "mode": "simulation"
        }


@router.get("/status/exploitation", response_model=Dict[str, Any])
async def get_exploitation_status(request: Request) -> Dict[str, Any]:
    """
    Get overall exploitation framework status.
    
    Returns:
        Exploitation framework health and statistics
    """
    try:
        use_real_exploits = getattr(request.app.state, 'use_real_exploits', False)
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        return {
            "mode": "real_exploitation" if use_real_exploits else "simulation",
            "metasploit": {
                "enabled": use_real_exploits,
                "connected": metasploit_adapter is not None and await metasploit_adapter.is_connected()
            },
            "c2": {
                "enabled": c2_manager is not None,
                "active_sessions": len(await c2_manager.list_sessions()) if c2_manager else 0
            },
            "capabilities": {
                "real_exploits": use_real_exploits and metasploit_adapter is not None,
                "post_exploitation": c2_manager is not None,
                "network_pivoting": c2_manager is not None,
                "credential_harvesting": c2_manager is not None
            }
        }
        
    except (ConnectionError, OSError, asyncio.TimeoutError) as e:
        # SEC-01: Handle connection errors
        logger.error(f"Connection error getting exploitation status: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Service temporarily unavailable"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to get exploitation status: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    except (KeyError, AttributeError) as e:
        # SEC-01: Handle attribute/lookup errors
        logger.warning(f"Error getting exploitation status: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve exploitation status"
        )


# ═══════════════════════════════════════════════════════════════
# Health Check
# ═══════════════════════════════════════════════════════════════

@router.get("/health", response_model=Dict[str, Any])
async def exploitation_health_check(request: Request) -> Dict[str, Any]:
    """
    Health check for exploitation framework.
    
    Returns:
        Health status of all exploitation components
    """
    try:
        use_real_exploits = getattr(request.app.state, 'use_real_exploits', False)
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        health = {
            "status": "healthy",
            "mode": "real_exploitation" if use_real_exploits else "simulation",
            "components": {}
        }
        
        # Check Metasploit
        if use_real_exploits and metasploit_adapter:
            try:
                connected = await metasploit_adapter.is_connected()
                health["components"]["metasploit"] = {
                    "status": "healthy" if connected else "unhealthy",
                    "connected": connected
                }
            except (ConnectionError, OSError, asyncio.TimeoutError) as e:
                # SEC-01: Specific handling for connection errors
                health["components"]["metasploit"] = {
                    "status": "unhealthy",
                    "error": "Connection error"
                }
                health["status"] = "degraded"
            except RAGLOXException as e:
                # SEC-01: Handle RAGLOX-specific exceptions
                health["components"]["metasploit"] = {
                    "status": "unhealthy",
                    "error": sanitize_error_message(e)
                }
                health["status"] = "degraded"
            except (AttributeError, ValueError) as e:
                # SEC-01: Handle configuration errors
                health["components"]["metasploit"] = {
                    "status": "unhealthy",
                    "error": "Configuration error"
                }
                health["status"] = "degraded"
        
        # Check C2
        if c2_manager:
            try:
                sessions = await c2_manager.list_sessions()
                health["components"]["c2"] = {
                    "status": "healthy",
                    "active_sessions": len(sessions)
                }
            except (ConnectionError, OSError, asyncio.TimeoutError) as e:
                # SEC-01: Specific handling for connection errors
                health["components"]["c2"] = {
                    "status": "unhealthy",
                    "error": "Connection error"
                }
                health["status"] = "degraded"
            except RAGLOXException as e:
                # SEC-01: Handle RAGLOX-specific exceptions
                health["components"]["c2"] = {
                    "status": "unhealthy",
                    "error": sanitize_error_message(e)
                }
                health["status"] = "degraded"
            except (AttributeError, ValueError) as e:
                # SEC-01: Handle configuration errors
                health["components"]["c2"] = {
                    "status": "unhealthy",
                    "error": "Configuration error"
                }
                health["status"] = "degraded"
        
        return health
        
    except (ConnectionError, OSError, asyncio.TimeoutError) as e:
        # SEC-01: Handle connection errors gracefully
        logger.error(f"Health check connection error: {sanitize_error_message(str(e))}")
        return {
            "status": "unhealthy",
            "error": "Connection error during health check"
        }
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Health check failed: {e.message}")
        return {
            "status": "unhealthy",
            "error": sanitize_error_message(e)
        }
    except (AttributeError, KeyError, ValueError) as e:
        # SEC-01: Handle configuration/lookup errors
        logger.error(f"Health check configuration error: {sanitize_error_message(str(e))}")
        return {
            "status": "unhealthy",
            "error": "Configuration error"
        }


# ═══════════════════════════════════════════════════════════════
# Exploit Repository Endpoints
# ═══════════════════════════════════════════════════════════════

@router.get("/exploits", response_model=List[ExploitInfo])
async def list_exploits(
    request: Request,
    platform: Optional[str] = None,
    cve_id: Optional[str] = None,
    min_reliability: Optional[str] = None
) -> List[ExploitInfo]:
    """
    List all available exploits from ExploitRepository.
    
    Args:
        platform: Filter by platform (windows, linux, etc.)
        cve_id: Filter by CVE ID
        min_reliability: Minimum reliability (excellent, great, good, normal)
    
    Returns:
        List of exploit information
    """
    try:
        from ..exploitation.knowledge.exploit_repository import get_exploit_repository
        
        repo = get_exploit_repository()
        exploits = repo.query_exploits(
            platform=platform,
            cve_id=cve_id,
            min_reliability=min_reliability
        )
        
        return [ExploitInfo(**exploit.dict()) for exploit in exploits]
        
    except ImportError as e:
        # SEC-01: Handle missing module
        logger.error(f"Exploit repository not available: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Exploit repository not available"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to list exploits: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    except (ValueError, AttributeError) as e:
        # SEC-01: Handle validation/attribute errors
        logger.warning(f"Error listing exploits: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid filter parameters"
        )


@router.get("/exploits/{exploit_id}", response_model=ExploitInfo)
async def get_exploit(request: Request, exploit_id: str) -> ExploitInfo:
    """Get detailed information about a specific exploit."""
    try:
        from ..exploitation.knowledge.exploit_repository import get_exploit_repository
        
        repo = get_exploit_repository()
        exploit = repo.get_exploit(exploit_id)
        
        if not exploit:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Exploit {exploit_id} not found"
            )
        
        return ExploitInfo(**exploit.dict())
        
    except HTTPException:
        raise
    except ImportError as e:
        # SEC-01: Handle missing module
        logger.error(f"Exploit repository not available: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Exploit repository not available"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to get exploit: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    except (KeyError, ValueError) as e:
        # SEC-01: Handle lookup/validation errors
        logger.warning(f"Error getting exploit: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Exploit not found"
        )


@router.get("/exploits/cve/{cve_id}", response_model=List[ExploitInfo])
async def find_exploits_by_cve(request: Request, cve_id: str) -> List[ExploitInfo]:
    """Find exploits by CVE ID."""
    try:
        from ..exploitation.knowledge.exploit_repository import get_exploit_repository
        
        repo = get_exploit_repository()
        exploits = repo.query_exploits(cve_id=cve_id)
        
        return [ExploitInfo(**exploit.dict()) for exploit in exploits]
        
    except ImportError as e:
        # SEC-01: Handle missing module
        logger.error(f"Exploit repository not available: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Exploit repository not available"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to find exploits by CVE: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    except ValueError as e:
        # SEC-01: Handle invalid CVE format
        logger.warning(f"Invalid CVE format: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid CVE format"
        )


@router.get("/exploits/stats", response_model=Dict[str, Any])
async def get_exploit_stats(request: Request) -> Dict[str, Any]:
    """
    Get exploit repository statistics.
    
    PERF-08: Response cached for 60 seconds.
    """
    # PERF-08: Check cache first
    cached = _exploit_stats_cache.get("stats")
    if cached:
        return cached
    
    try:
        from ..exploitation.knowledge.exploit_repository import get_exploit_repository
        
        repo = get_exploit_repository()
        stats = repo.get_statistics()
        
        # Cache the result
        _exploit_stats_cache.set("stats", stats)
        
        return stats
        
    except ImportError as e:
        # SEC-01: Handle missing module
        logger.error(f"Exploit repository not available: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Exploit repository not available"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to get exploit stats: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    except (AttributeError, ValueError) as e:
        # SEC-01: Handle configuration errors
        logger.warning(f"Error getting exploit stats: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to compute exploit statistics"
        )


@router.delete("/cache/clear")
async def clear_response_caches() -> Dict[str, str]:
    """
    Clear all response caches.
    
    Use this endpoint to force fresh data retrieval.
    """
    _metasploit_status_cache.clear()
    _exploitation_status_cache.clear()
    _exploit_stats_cache.clear()
    
    return {
        "status": "success",
        "message": "All response caches cleared"
    }


# ═══════════════════════════════════════════════════════════════
# Payload Generation Endpoints
# ═══════════════════════════════════════════════════════════════

@router.post("/payloads/generate", response_model=PayloadResponse)
async def generate_payload(
    request: Request,
    payload_request: PayloadRequest
) -> PayloadResponse:
    """
    Generate a custom payload.
    
    Args:
        payload_request: Payload configuration
    
    Returns:
        Generated payload data
    """
    try:
        from ..exploitation.payloads.payload_generator import get_payload_generator
        
        generator = get_payload_generator()
        
        # Generate payload
        result = await generator.generate_payload(
            payload_type=payload_request.payload_type,
            lhost=payload_request.lhost,
            lport=payload_request.lport,
            target_os=payload_request.target_os,
            architecture=payload_request.architecture,
            encoder=payload_request.encoder,
            iterations=payload_request.iterations
        )
        
        return PayloadResponse(
            success=result.get("success", False),
            payload_type=payload_request.payload_type,
            payload_data=result.get("payload", ""),
            payload_size=len(result.get("payload", "")),
            encoded=payload_request.encoder is not None,
            encoder=payload_request.encoder
        )
        
    except ImportError as e:
        # SEC-01: Handle missing module
        logger.error(f"Payload generator not available: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Payload generator not available"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to generate payload: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    except ValueError as e:
        # SEC-01: Handle invalid parameters
        logger.warning(f"Invalid payload parameters: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid payload configuration"
        )


@router.get("/payloads/types", response_model=List[str])
async def list_payload_types(request: Request) -> List[str]:
    """List available payload types."""
    return [
        "reverse_shell",
        "bind_shell",
        "meterpreter",
        "meterpreter_reverse_tcp",
        "meterpreter_bind_tcp",
        "meterpreter_reverse_https",
        "windows_shell",
        "linux_shell",
        "powershell",
        "shellcode"
    ]


# ═══════════════════════════════════════════════════════════════
# Post-Exploitation: Credential Harvesting
# ═══════════════════════════════════════════════════════════════

@router.post("/post-exploitation/harvest", response_model=Dict[str, Any])
async def harvest_credentials(
    request: Request,
    harvest_request: CredentialHarvestRequest
) -> Dict[str, Any]:
    """
    Harvest credentials from a compromised host.
    
    Args:
        harvest_request: Harvesting configuration
    
    Returns:
        Harvested credentials
    """
    try:
        from ..exploitation.post_exploitation.credential_harvester import CredentialHarvester
        
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not available"
            )
        
        harvester = CredentialHarvester(c2_manager=c2_manager)
        
        # Harvest based on type
        if harvest_request.harvest_type == "mimikatz":
            result = await harvester.run_mimikatz(harvest_request.session_id)
        elif harvest_request.harvest_type == "lsass":
            result = await harvester.dump_lsass(harvest_request.session_id)
        elif harvest_request.harvest_type == "sam":
            result = await harvester.dump_sam(harvest_request.session_id)
        elif harvest_request.harvest_type == "browsers":
            result = await harvester.extract_browser_credentials(harvest_request.session_id)
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid harvest type: {harvest_request.harvest_type}"
            )
        
        return result
        
    except HTTPException:
        raise
    except ImportError as e:
        # SEC-01: Handle missing module
        logger.error(f"Credential harvester not available: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Credential harvester not available"
        )
    except (ConnectionError, OSError, asyncio.TimeoutError) as e:
        # SEC-01: Handle connection errors
        logger.error(f"Connection error harvesting credentials: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Session connection error"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to harvest credentials: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    except (ValueError, KeyError) as e:
        # SEC-01: Handle validation errors
        logger.warning(f"Invalid harvest parameters: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid harvesting parameters"
        )


# ═══════════════════════════════════════════════════════════════
# Post-Exploitation: Network Pivoting
# ═══════════════════════════════════════════════════════════════

@router.post("/pivoting/port-forward", response_model=Dict[str, Any])
async def setup_port_forward(
    request: Request,
    forward_request: PortForwardRequest
) -> Dict[str, Any]:
    """Setup port forwarding through a compromised host."""
    try:
        from ..exploitation.post_exploitation.network_pivoting import NetworkPivoting
        
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not available"
            )
        
        pivoting = NetworkPivoting(c2_manager=c2_manager)
        
        result = await pivoting.setup_port_forward(
            session_id=forward_request.session_id,
            local_port=forward_request.local_port,
            remote_host=forward_request.remote_host,
            remote_port=forward_request.remote_port
        )
        
        return result
        
    except ImportError as e:
        # SEC-01: Handle missing module
        logger.error(f"Network pivoting module not available: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Network pivoting not available"
        )
    except (ConnectionError, OSError, asyncio.TimeoutError) as e:
        # SEC-01: Handle connection errors
        logger.error(f"Connection error setting up port forward: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Session connection error"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to setup port forward: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    except ValueError as e:
        # SEC-01: Handle invalid port/host
        logger.warning(f"Invalid port forward parameters: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid port forward configuration"
        )


@router.get("/pivoting/routes", response_model=List[Dict[str, Any]])
async def list_pivot_routes(request: Request, session_id: Optional[str] = None) -> List[Dict[str, Any]]:
    """List all active pivot routes."""
    try:
        from ..exploitation.post_exploitation.network_pivoting import NetworkPivoting
        
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        if not c2_manager:
            return []
        
        pivoting = NetworkPivoting(c2_manager=c2_manager)
        routes = await pivoting.list_routes(session_id=session_id)
        
        return routes
        
    except ImportError as e:
        # SEC-01: Handle missing module
        logger.error(f"Network pivoting module not available: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Network pivoting not available"
        )
    except (ConnectionError, OSError, asyncio.TimeoutError) as e:
        # SEC-01: Handle connection errors
        logger.error(f"Connection error listing pivot routes: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Session connection error"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to list pivot routes: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )


# ═══════════════════════════════════════════════════════════════
# Specific Exploit Execution Endpoints
# ═══════════════════════════════════════════════════════════════

@router.post("/exploits/eternalblue/execute", response_model=Dict[str, Any])
async def execute_eternalblue(
    request: Request,
    target_host: str,
    target_port: int = 445,
    lhost: Optional[str] = None,
    lport: int = 4444
) -> Dict[str, Any]:
    """
    Execute EternalBlue (MS17-010) exploit against target.
    
    Args:
        target_host: Target Windows host
        target_port: SMB port (default 445)
        lhost: Listener host for reverse shell
        lport: Listener port
    
    Returns:
        Exploit execution result
    """
    try:
        from ..exploitation.exploits.eternalblue import EternalBlueExploit
        from ..exploitation.adapters.metasploit_adapter import get_metasploit_adapter
        
        metasploit = get_metasploit_adapter()
        exploit = EternalBlueExploit(metasploit_adapter=metasploit)
        
        result = await exploit.execute(
            target_host=target_host,
            target_port=target_port,
            lhost=lhost or request.app.state.settings.lhost,
            lport=lport
        )
        
        return result
        
    except ImportError as e:
        # SEC-01: Handle missing module
        logger.error(f"EternalBlue exploit module not available: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Exploit module not available"
        )
    except asyncio.TimeoutError as e:
        # SEC-01: Handle exploit timeout
        logger.warning(f"EternalBlue exploit timed out: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_504_GATEWAY_TIMEOUT,
            detail="Exploit execution timed out"
        )
    except (ConnectionError, OSError) as e:
        # SEC-01: Handle connection errors
        logger.error(f"Connection error executing EternalBlue: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Unable to connect to target"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"EternalBlue exploit failed: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )


@router.post("/exploits/eternalblue/check", response_model=Dict[str, Any])
async def check_eternalblue(
    request: Request,
    target_host: str,
    target_port: int = 445
) -> Dict[str, Any]:
    """
    Check if target is vulnerable to EternalBlue.
    
    Args:
        target_host: Target Windows host
        target_port: SMB port (default 445)
    
    Returns:
        Vulnerability check result
    """
    try:
        from ..exploitation.exploits.eternalblue import EternalBlueExploit
        from ..exploitation.adapters.metasploit_adapter import get_metasploit_adapter
        
        metasploit = get_metasploit_adapter()
        exploit = EternalBlueExploit(metasploit_adapter=metasploit)
        
        result = await exploit.check_vulnerability(
            target_host=target_host,
            target_port=target_port
        )
        
        return result
        
    except ImportError as e:
        # SEC-01: Handle missing module
        logger.error(f"EternalBlue exploit module not available: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Exploit module not available"
        )
    except asyncio.TimeoutError as e:
        # SEC-01: Handle check timeout
        logger.warning(f"EternalBlue vulnerability check timed out: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_504_GATEWAY_TIMEOUT,
            detail="Vulnerability check timed out"
        )
    except (ConnectionError, OSError) as e:
        # SEC-01: Handle connection errors
        logger.error(f"Connection error checking EternalBlue: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Unable to connect to target"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"EternalBlue vulnerability check failed: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )


@router.post("/exploits/log4shell/execute", response_model=Dict[str, Any])
async def execute_log4shell(
    request: Request,
    target_url: str,
    target_port: int = 8080,
    lhost: Optional[str] = None,
    lport: int = 4444,
    jndi_payload: Optional[str] = None
) -> Dict[str, Any]:
    """
    Execute Log4Shell (CVE-2021-44228) exploit against target.
    
    Args:
        target_url: Target URL with Log4j
        target_port: Target port
        lhost: Listener host for reverse shell
        lport: Listener port
        jndi_payload: Custom JNDI payload (optional)
    
    Returns:
        Exploit execution result
    """
    try:
        from ..exploitation.exploits.log4shell import Log4ShellExploit
        from ..exploitation.adapters.metasploit_adapter import get_metasploit_adapter
        
        metasploit = get_metasploit_adapter()
        exploit = Log4ShellExploit(metasploit_adapter=metasploit)
        
        result = await exploit.execute(
            target_url=target_url,
            target_port=target_port,
            lhost=lhost or request.app.state.settings.lhost,
            lport=lport,
            jndi_payload=jndi_payload
        )
        
        return result
        
    except ImportError as e:
        # SEC-01: Handle missing module
        logger.error(f"Log4Shell exploit module not available: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Exploit module not available"
        )
    except asyncio.TimeoutError as e:
        # SEC-01: Handle exploit timeout
        logger.warning(f"Log4Shell exploit timed out: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_504_GATEWAY_TIMEOUT,
            detail="Exploit execution timed out"
        )
    except (ConnectionError, OSError) as e:
        # SEC-01: Handle connection errors
        logger.error(f"Connection error executing Log4Shell: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Unable to connect to target"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Log4Shell exploit failed: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )


@router.post("/exploits/log4shell/scan", response_model=Dict[str, Any])
async def scan_log4shell(
    request: Request,
    target_url: str
) -> Dict[str, Any]:
    """
    Scan target for Log4Shell vulnerability.
    
    Args:
        target_url: Target URL to scan
    
    Returns:
        Scan result with vulnerability status
    """
    try:
        from ..exploitation.exploits.log4shell import Log4ShellExploit
        from ..exploitation.adapters.metasploit_adapter import get_metasploit_adapter
        
        metasploit = get_metasploit_adapter()
        exploit = Log4ShellExploit(metasploit_adapter=metasploit)
        
        result = await exploit.scan_vulnerability(target_url=target_url)
        
        return result
        
    except ImportError as e:
        # SEC-01: Handle missing module
        logger.error(f"Log4Shell exploit module not available: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Exploit module not available"
        )
    except asyncio.TimeoutError as e:
        # SEC-01: Handle scan timeout
        logger.warning(f"Log4Shell scan timed out: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_504_GATEWAY_TIMEOUT,
            detail="Vulnerability scan timed out"
        )
    except (ConnectionError, OSError) as e:
        # SEC-01: Handle connection errors
        logger.error(f"Connection error scanning Log4Shell: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Unable to connect to target"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Log4Shell scan failed: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )


# ═══════════════════════════════════════════════════════════════
# Metasploit Direct Interaction
# ═══════════════════════════════════════════════════════════════

@router.get("/metasploit/modules", response_model=List[str])
async def list_metasploit_modules(
    request: Request,
    module_type: Optional[str] = None
) -> List[str]:
    """
    List available Metasploit modules.
    
    Args:
        module_type: Filter by type (exploit, auxiliary, post, etc.)
    
    Returns:
        List of module names
    """
    try:
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        
        if not metasploit_adapter:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Metasploit adapter not available"
            )
        
        modules = await metasploit_adapter.list_modules(module_type=module_type)
        
        return modules
        
    except HTTPException:
        raise
    except (ConnectionError, OSError, asyncio.TimeoutError) as e:
        # SEC-01: Handle connection errors
        logger.error(f"Connection error listing Metasploit modules: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Unable to connect to Metasploit"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to list Metasploit modules: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    except (AttributeError, ValueError) as e:
        # SEC-01: Handle configuration errors
        logger.warning(f"Error listing Metasploit modules: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve module list"
        )


@router.post("/metasploit/execute", response_model=Dict[str, Any])
async def execute_metasploit_module(
    request: Request,
    module_name: str,
    options: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Execute a Metasploit module with custom options.
    
    Args:
        module_name: Full module path (e.g., exploit/windows/smb/ms17_010_eternalblue)
        options: Module options (RHOSTS, RPORT, LHOST, LPORT, etc.)
    
    Returns:
        Execution result
    """
    try:
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        
        if not metasploit_adapter:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Metasploit adapter not available"
            )
        
        result = await metasploit_adapter.execute_module(
            module_name=module_name,
            options=options
        )
        
        return result
        
    except HTTPException:
        raise
    except asyncio.TimeoutError as e:
        # SEC-01: Handle module execution timeout
        logger.warning(f"Metasploit module execution timed out: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_504_GATEWAY_TIMEOUT,
            detail="Module execution timed out"
        )
    except (ConnectionError, OSError) as e:
        # SEC-01: Handle connection errors
        logger.error(f"Connection error executing Metasploit module: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Unable to connect to Metasploit"
        )
    except RAGLOXException as e:
        # SEC-01: Handle RAGLOX-specific exceptions
        logger.error(f"Failed to execute Metasploit module: {e.message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=e.message
        )
    except ValueError as e:
        # SEC-01: Handle invalid module options
        logger.warning(f"Invalid module options: {sanitize_error_message(str(e))}")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid module options"
        )
