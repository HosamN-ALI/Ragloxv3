# ═══════════════════════════════════════════════════════════════
# RAGLOX v3.0 - Exploitation & C2 API Routes
# Real-time session management and exploitation monitoring
# ═══════════════════════════════════════════════════════════════

import logging
from typing import Dict, List, Optional, Any
from fastapi import APIRouter, HTTPException, status, Depends, Request
from pydantic import BaseModel, Field

logger = logging.getLogger("raglox.api.exploitation")

router = APIRouter(prefix="/exploitation", tags=["Exploitation"])


# ═══════════════════════════════════════════════════════════════
# Request/Response Models
# ═══════════════════════════════════════════════════════════════

class C2SessionInfo(BaseModel):
    """C2 Session information."""
    session_id: str
    target_host: str
    target_port: int
    session_type: str  # "ssh", "meterpreter", "shell", etc.
    status: str  # "active", "inactive", "error"
    created_at: str
    last_heartbeat: Optional[str] = None
    encryption_enabled: bool
    privilege_level: Optional[str] = None
    commands_executed: int = 0
    data_exfiltrated_bytes: int = 0


class C2CommandRequest(BaseModel):
    """Execute command on C2 session."""
    session_id: str = Field(..., description="Target C2 session ID")
    command: str = Field(..., description="Command to execute")
    timeout: int = Field(default=30, description="Command timeout in seconds")


class C2CommandResponse(BaseModel):
    """C2 command execution result."""
    success: bool
    session_id: str
    command: str
    output: Optional[str] = None
    error: Optional[str] = None
    execution_time: float
    timestamp: str


class ExploitStatusRequest(BaseModel):
    """Request exploit status."""
    exploit_id: Optional[str] = None
    target_id: Optional[str] = None


class ExploitStatusResponse(BaseModel):
    """Exploit execution status."""
    exploit_id: str
    target_id: str
    status: str  # "pending", "running", "success", "failed"
    exploit_type: str
    started_at: str
    completed_at: Optional[str] = None
    session_id: Optional[str] = None
    error: Optional[str] = None


class SessionProxyRequest(BaseModel):
    """Setup SOCKS proxy via session."""
    session_id: str
    proxy_port: int = Field(default=1080, description="Local SOCKS proxy port")
    proxy_type: str = Field(default="socks5", description="Proxy type: socks4/socks5")


# ═══════════════════════════════════════════════════════════════
# C2 Session Management Endpoints
# ═══════════════════════════════════════════════════════════════

@router.get("/c2/sessions", response_model=List[C2SessionInfo])
async def list_c2_sessions(
    request: Request,
    mission_id: Optional[str] = None,
    status: Optional[str] = None
) -> List[C2SessionInfo]:
    """
    List all active C2 sessions.
    
    Args:
        mission_id: Filter by mission ID (optional)
        status: Filter by status: active/inactive/error (optional)
    
    Returns:
        List of C2 session information
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized. Enable USE_REAL_EXPLOITS=true"
            )
        
        # Get all sessions
        sessions = await c2_manager.list_sessions()
        
        # Apply filters
        if mission_id:
            sessions = [s for s in sessions if s.get('mission_id') == mission_id]
        if status:
            sessions = [s for s in sessions if s.get('status') == status]
        
        return [C2SessionInfo(**s) for s in sessions]
        
    except Exception as e:
        logger.error(f"Failed to list C2 sessions: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list C2 sessions: {str(e)}"
        )


@router.get("/c2/sessions/{session_id}", response_model=C2SessionInfo)
async def get_c2_session(
    request: Request,
    session_id: str
) -> C2SessionInfo:
    """
    Get detailed information about a specific C2 session.
    
    Args:
        session_id: C2 session ID
    
    Returns:
        C2 session information
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        session = await c2_manager.get_session(session_id)
        
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"C2 session {session_id} not found"
            )
        
        return C2SessionInfo(**session)
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get C2 session: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get C2 session: {str(e)}"
        )


@router.post("/c2/sessions/{session_id}/execute", response_model=C2CommandResponse)
async def execute_c2_command(
    request: Request,
    session_id: str,
    command_request: C2CommandRequest
) -> C2CommandResponse:
    """
    Execute a command on a C2 session.
    
    Args:
        session_id: Target C2 session ID
        command_request: Command details
    
    Returns:
        Command execution result
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        # Execute command
        result = await c2_manager.execute_command(
            session_id=session_id,
            command=command_request.command,
            timeout=command_request.timeout
        )
        
        return C2CommandResponse(**result)
        
    except Exception as e:
        logger.error(f"Failed to execute command: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to execute command: {str(e)}"
        )


@router.delete("/c2/sessions/{session_id}")
async def terminate_c2_session(
    request: Request,
    session_id: str
) -> Dict[str, str]:
    """
    Terminate a C2 session.
    
    Args:
        session_id: C2 session ID to terminate
    
    Returns:
        Success message
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        await c2_manager.terminate_session(session_id)
        
        return {
            "status": "success",
            "message": f"C2 session {session_id} terminated"
        }
        
    except Exception as e:
        logger.error(f"Failed to terminate session: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to terminate session: {str(e)}"
        )


@router.post("/c2/sessions/{session_id}/proxy", response_model=Dict[str, Any])
async def setup_socks_proxy(
    request: Request,
    session_id: str,
    proxy_request: SessionProxyRequest
) -> Dict[str, Any]:
    """
    Setup SOCKS proxy through a C2 session for network pivoting.
    
    Args:
        session_id: C2 session to use for proxy
        proxy_request: Proxy configuration
    
    Returns:
        Proxy connection details
    """
    try:
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        if not c2_manager:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="C2 Session Manager not initialized"
            )
        
        # Setup SOCKS proxy
        proxy_info = await c2_manager.setup_proxy(
            session_id=session_id,
            proxy_port=proxy_request.proxy_port,
            proxy_type=proxy_request.proxy_type
        )
        
        return {
            "status": "success",
            "proxy_type": proxy_request.proxy_type,
            "proxy_host": "127.0.0.1",
            "proxy_port": proxy_request.proxy_port,
            "session_id": session_id,
            "message": f"SOCKS proxy established on port {proxy_request.proxy_port}"
        }
        
    except Exception as e:
        logger.error(f"Failed to setup proxy: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to setup proxy: {str(e)}"
        )


# ═══════════════════════════════════════════════════════════════
# Exploitation Status & Monitoring
# ═══════════════════════════════════════════════════════════════

@router.get("/status/metasploit", response_model=Dict[str, Any])
async def get_metasploit_status(request: Request) -> Dict[str, Any]:
    """
    Get Metasploit RPC connection status.
    
    Returns:
        Metasploit connection and version information
    """
    try:
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        use_real_exploits = getattr(request.app.state, 'use_real_exploits', False)
        
        if not use_real_exploits:
            return {
                "status": "disabled",
                "message": "Real exploitation disabled. Set USE_REAL_EXPLOITS=true",
                "mode": "simulation"
            }
        
        if not metasploit_adapter:
            return {
                "status": "unavailable",
                "message": "Metasploit RPC adapter not initialized",
                "mode": "simulation"
            }
        
        # Get Metasploit version and stats
        version = await metasploit_adapter.get_version()
        exploits = await metasploit_adapter.list_exploits()
        
        return {
            "status": "connected",
            "mode": "real_exploitation",
            "version": version,
            "total_exploits": len(exploits) if exploits else 0,
            "connection": {
                "host": metasploit_adapter.host,
                "port": metasploit_adapter.port,
                "ssl": metasploit_adapter.ssl
            }
        }
        
    except Exception as e:
        logger.error(f"Failed to get Metasploit status: {e}")
        return {
            "status": "error",
            "message": str(e),
            "mode": "simulation"
        }


@router.get("/status/exploitation", response_model=Dict[str, Any])
async def get_exploitation_status(request: Request) -> Dict[str, Any]:
    """
    Get overall exploitation framework status.
    
    Returns:
        Exploitation framework health and statistics
    """
    try:
        use_real_exploits = getattr(request.app.state, 'use_real_exploits', False)
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        return {
            "mode": "real_exploitation" if use_real_exploits else "simulation",
            "metasploit": {
                "enabled": use_real_exploits,
                "connected": metasploit_adapter is not None and await metasploit_adapter.is_connected()
            },
            "c2": {
                "enabled": c2_manager is not None,
                "active_sessions": len(await c2_manager.list_sessions()) if c2_manager else 0
            },
            "capabilities": {
                "real_exploits": use_real_exploits and metasploit_adapter is not None,
                "post_exploitation": c2_manager is not None,
                "network_pivoting": c2_manager is not None,
                "credential_harvesting": c2_manager is not None
            }
        }
        
    except Exception as e:
        logger.error(f"Failed to get exploitation status: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get exploitation status: {str(e)}"
        )


# ═══════════════════════════════════════════════════════════════
# Health Check
# ═══════════════════════════════════════════════════════════════

@router.get("/health", response_model=Dict[str, Any])
async def exploitation_health_check(request: Request) -> Dict[str, Any]:
    """
    Health check for exploitation framework.
    
    Returns:
        Health status of all exploitation components
    """
    try:
        use_real_exploits = getattr(request.app.state, 'use_real_exploits', False)
        metasploit_adapter = getattr(request.app.state, 'metasploit_adapter', None)
        c2_manager = getattr(request.app.state, 'c2_manager', None)
        
        health = {
            "status": "healthy",
            "mode": "real_exploitation" if use_real_exploits else "simulation",
            "components": {}
        }
        
        # Check Metasploit
        if use_real_exploits and metasploit_adapter:
            try:
                connected = await metasploit_adapter.is_connected()
                health["components"]["metasploit"] = {
                    "status": "healthy" if connected else "unhealthy",
                    "connected": connected
                }
            except Exception as e:
                health["components"]["metasploit"] = {
                    "status": "unhealthy",
                    "error": str(e)
                }
                health["status"] = "degraded"
        
        # Check C2
        if c2_manager:
            try:
                sessions = await c2_manager.list_sessions()
                health["components"]["c2"] = {
                    "status": "healthy",
                    "active_sessions": len(sessions)
                }
            except Exception as e:
                health["components"]["c2"] = {
                    "status": "unhealthy",
                    "error": str(e)
                }
                health["status"] = "degraded"
        
        return health
        
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        return {
            "status": "unhealthy",
            "error": str(e)
        }
